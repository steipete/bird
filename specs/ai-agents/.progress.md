---
spec: ai-agents
phase: research
task: 0/0
updated: 2026-01-19T00:00:00Z
---

# Progress: ai-agents

## Original Goal

Monitor X/Twitter for posts on 'AI Agents' by influencers with > 50k followers, write an intelligent reply within 5 minutes of their posting so we get maximum visibility. See overview.md for details. MVP level, do not overbuild, indie maker ethos.

## Completed Tasks

- [x] 1.1 Project setup - dependencies and TypeScript config - d8f8080
- [x] 1.2 TypeScript types - core interfaces - f55835f

## Current Task

Awaiting next task

## Learnings

_Discoveries and insights will be captured here_

## Blockers

- None currently

## Next

Task 1.3: Config loader - environment validation

## Learnings
- Bird CLI does NOT support PDF upload - X/Twitter renders PDFs poorly. Must convert PDF→PNG before upload.
- Bird's follower count lookup is available via `getUserByScreenNameGraphQL()` - returns full profile with `followersCount`.
- X/Twitter spam detection is REAL: identical content, high frequency, and bulk actions trigger blocks. Conservative rate limits (10-15/day, 10min gaps) are essential.
- Bun has built-in `bun:sqlite` module that's 3-6x faster than better-sqlite3 - perfect for this project.
- Manus API uses task-based async workflow: create task → poll status → download result. Expect 60-90s generation time.
- Bird uses undocumented GraphQL API with rotating query IDs - can break without notice. This is an accepted risk.
- X deprecated v1.1 media upload on March 31, 2025. Bird handles this internally via GraphQL.
- Best practice: Keep 30% activity manual to avoid bot detection. Start with warm-up period (1-3 weeks).
- Author caching strategy: Cache follower counts for 24h to reduce API calls and avoid rate limits on user lookups.
- Quality commands discovered: `pnpm run lint`, `pnpm test`, `pnpm run build` all available and working.
- Requirements phase: Primary user is internal developers (backend automation), not end users. No UI needed.
- Critical MVP priorities: P0 = core pipeline (poll, filter, generate, reply), P1 = error handling, P2 = optimizations.
- Dry-run mode is non-negotiable for safe testing before production deployment.
- Deduplication must be atomic: check + insert in single transaction to prevent race conditions.
- 5-minute reply window is hard constraint - drives all latency targets (Manus <120s, PNG conversion <5s).
- Reply text variation (5+ templates) is P0 requirement - identical text triggers spam detection immediately.
- Circuit breaker pattern essential for Manus failures - prevents wasting time on degraded service.
- Author cache hit rate >60% after warmup is key performance indicator - reduces API calls significantly.
- Design phase: Standalone application architecture chosen over integrated bird module for cleaner separation and independent deployment.
- Bird uses mixin architecture for composability - TwitterClient composes multiple mixins (search, posting, media, etc.).
- Bird error pattern: Return `{ success: boolean; error?: string; data?: T }` instead of throwing exceptions (except critical failures).
- Bird module system: ES modules with NodeNext resolution, all imports use `.js` extensions even for TypeScript files.
- Filter pipeline architecture: Multi-stage validation (content → deduplication → followers → rate limits) for clear separation and debuggability.
- Circuit breaker only for Manus: Bird has built-in retry logic, Manus is highest latency/failure risk (60-90s generation time).
- Database singleton pattern for rate_limits table: Single row (id=1) stores global rate limit state, prevents race conditions.
- Security: All DB queries must use parameterized queries (bun:sqlite supports), mask secrets in logs, .env in .gitignore.
- Performance budget breakdown: 70-120s typical, 300s max (5min), 90th percentile target <180s for full pipeline.
- Testing strategy: Unit tests for filters/config (90%+), integration tests with real SQLite in-memory, dry-run mode for end-to-end validation.
- Task planning: 47 total tasks across 4 phases (POC, Refactoring, Testing, Quality Gates) following POC-first workflow.
- POC phase focuses on working pipeline demonstration with shortcuts (hardcoded values, minimal validation, no tests).
- Phase 1 critical path: Project setup → Types → Config → Logger → Database → Poller → Filter → Generator → Responder → Main orchestrator → E2E validation.
- Quality checkpoints every 2-3 tasks prevent accumulation of type errors and lint issues.
- Phase 2 refactoring adds robustness: follower count filtering, rate limit enforcement, retry logic, circuit breaker, comprehensive error handling, graceful shutdown.
- Phase 3 testing is comprehensive per user request: unit tests (config, filters, templates, DB), integration tests (filter+DB, Manus API), E2E tests (full pipeline, real Twitter).
- E2E validation strategy: POC uses manual script with dry-run mode, Testing phase adds automated E2E with mocks plus optional real API tests when credentials available.
- Phase 4 quality gates: Biome+Oxlint linting, strict TypeScript, full test suite, README documentation, PR with passing CI.
- Dependency on Manus API: Must test real PDF generation in E2E validation (Task 1.23, 3.8) to verify integration works, not just that code compiles.
- Author cache seeding (Task 1.21) critical for startup performance - pre-populates 12 known influencers to avoid cold-start API calls.
- Circuit breaker state persisted in DB singleton row alongside rate limits - enables restart resilience without losing failure tracking.
- Dry-run mode testing non-negotiable for safe pre-production validation - all pipeline stages execute but skip actual Twitter posting.
- Bun types: Use @types/bun (not bun-types) in devDependencies, and "types": ["node", "bun"] in tsconfig.json (not "bun-types").
- Bird dependency: Use file:.. reference (not workspace:*) since this is a standalone app in the same repo without pnpm workspaces configured.
